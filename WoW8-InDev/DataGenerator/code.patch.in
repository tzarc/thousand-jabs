diff --git a/engine/sc_main.cpp b/engine/sc_main.cpp
index 7eed68b..53048bb 100644
--- a/engine/sc_main.cpp
+++ b/engine/sc_main.cpp
@@ -239,6 +239,9 @@ void print_exception(const std::exception& e, int level =  0)

 // sim_t::main ==============================================================

+bool do_tj_hook = false;
+extern int run_tj_hook(sim_t *sim);
+
 int sim_t::main( const std::vector<std::string>& args )
 {
   try
@@ -278,6 +281,11 @@ int sim_t::main( const std::vector<std::string>& args )
     // begins
     hotfix::apply();

+    if(do_tj_hook)
+    {
+        return run_tj_hook(this);
+    }
+
     try
     {
       setup( &control );
@@ -371,7 +379,7 @@ int sim_t::main( const std::vector<std::string>& args )
 // MAIN
 // ==========================================================================

-int main( int argc, char** argv )
+int run_simc( int argc, char** argv )
 {
   std::locale::global( std::locale( "C" ) );
 #if defined( SC_VS ) && SC_VS < 13
@@ -379,8 +387,25 @@ int main( int argc, char** argv )
   _set_output_format( _TWO_DIGIT_EXPONENT );
 #endif

+  if (argc > 1 && util::str_compare_ci(argv[1], "tj"))
+  {
+      do_tj_hook = true;
+      argv[1] = argv[0];
+      argv = &argv[1];
+      --argc;
+  }
+
   sim_t sim;
   sim_signal_handler_t::global_sim = &sim;

   return sim.main( io::utf8_args( argc, argv ) );
 }
+
+extern int run_tj(void);
+
+int main( int argc, char** argv )
+{
+    if (argc > 1 && util::str_compare_ci(argv[1], "tj"))
+        return run_tj();
+    return run_simc(argc, argv);
+}
diff --git a/source_files/engine_main_make b/source_files/engine_main_make
index f85e1ab..a1d6198 100644
--- a/source_files/engine_main_make
+++ b/source_files/engine_main_make
@@ -2,4 +2,6 @@
 # To change the list of source files, update the QT_ files and run synchronize.py

 SRC += \
-    sc_main.cpp \
\ No newline at end of file
+    sc_main.cpp \
+    @@@tj_main@@@ \
+    @@@tj_hook@@@ \
\ No newline at end of file
diff --git a/source_files/cmake_engine_main.txt b/source_files/cmake_engine_main.txt
index bb615189..d1b6410d 100644
--- a/source_files/cmake_engine_main.txt
+++ b/source_files/cmake_engine_main.txt
@@ -1,3 +1,5 @@
 set(source_files
 sc_main.cpp
-)
\ No newline at end of file
+@@@tj_main@@@
+@@@tj_hook@@@
+)
diff --git a/engine/dbc/sc_spell_info.cpp b/engine/dbc/sc_spell_info.cpp
index 0c10391c..6bcac7cf 100644
--- a/engine/dbc/sc_spell_info.cpp
+++ b/engine/dbc/sc_spell_info.cpp
@@ -2213,3 +2213,79 @@ void spell_info::set_bonus_to_xml( const dbc_t& /* dbc */, const item_set_bonus_
   node -> add_parm( "spell_id", set_bonus -> spell_id );
 
 }
+
+const char* tj_get_class_name(player_e pt)
+{
+    const auto* ptr = &_class_map[1];
+    while(ptr->name)
+    {
+        if(ptr->pt == pt)
+            return ptr->name;
+        ++ptr;
+    }
+    return "<Unknown Class>";
+}
+
+const char* tj_get_race_name(unsigned raceID)
+{
+    auto it = _race_map.find(raceID);
+    if(it == std::end(_race_map))
+        return "<Unknown Race>";
+    return it->second.c_str();
+}
+
+const char* tj_get_target(unsigned targetType)
+{
+    auto it = _targeting_strings.find(targetType);
+    if(it == std::end(_targeting_strings))
+        return "<Unknown Target>";
+    return it->second.c_str();
+}
+
+const char* tj_get_resource(int resourceID)
+{
+    auto it = _resource_strings.find(resourceID);
+    if(it == std::end(_resource_strings))
+        return "<Unknown Resource>";
+    return it->second.c_str();
+}
+
+const char* tj_get_attribute(unsigned attributeID)
+{
+    auto it = _attribute_strings.find(attributeID);
+    if(it == std::end(_attribute_strings))
+        return "<Unknown Attribute>";
+    return it->second.c_str();
+}
+
+const char* tj_get_property_type(unsigned propertyType)
+{
+    auto it = _property_type_strings.find(propertyType);
+    if(it == std::end(_property_type_strings))
+        return "<Unknown Property>";
+    return it->second.c_str();
+}
+
+const char* tj_get_effect_type(unsigned effectType)
+{
+    auto it = _effect_type_strings.find(effectType);
+    if(it == std::end(_effect_type_strings))
+        return "<Unknown Effect>";
+    return it->second.c_str();
+}
+
+const char* tj_get_subeffect_type(unsigned subeffectType)
+{
+    auto it = _effect_subtype_strings.find(subeffectType);
+    if(it == std::end(_effect_subtype_strings))
+        return "<Unknown Subeffect>";
+    return it->second.c_str();
+}
+
+const char* tj_get_mechanic_type(unsigned mechanicType)
+{
+    auto it = _mechanic_strings.find(mechanicType);
+    if(it == std::end(_mechanic_strings))
+        return "<Unknown Mechanic>";
+    return it->second;
+}
